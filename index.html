<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Nike Gaussian Splat Viewer</title>
    <style>
        body, html {
            margin: 0;
            padding: 0;
            width: 100%;
            height: 100%;
            overflow: hidden;
            font-family: Arial, sans-serif;
        }
        #container {
            width: 100%;
            height: 100%;
            position: relative;
        }
        #canvas {
            width: 100%;
            height: 100%;
            display: block;
        }
        #loading {
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            color: white;
            background-color: rgba(0, 0, 0, 0.7);
            padding: 20px;
            border-radius: 10px;
            text-align: center;
        }
        #info {
            position: absolute;
            bottom: 10px;
            left: 10px;
            color: white;
            background-color: rgba(0, 0, 0, 0.5);
            padding: 10px;
            border-radius: 5px;
            font-size: 14px;
        }
    </style>
</head>
<body>
    <div id="container">
        <canvas id="canvas"></canvas>
        <div id="loading">Loading Gaussian Splat Model...</div>
        <div id="info">
            Mouse: Left click + drag to rotate | Right click + drag to pan | Scroll to zoom
        </div>
    </div>

    <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
    <script>
        // Main application
        class GaussianSplatViewer {
            constructor() {
                this.canvas = document.getElementById('canvas');
                this.loadingElement = document.getElementById('loading');
                
                this.scene = new THREE.Scene();
                this.camera = new THREE.PerspectiveCamera(75, window.innerWidth / window.innerHeight, 0.1, 1000);
                this.renderer = new THREE.WebGLRenderer({ canvas: this.canvas, antialias: true });
                this.renderer.setSize(window.innerWidth, window.innerHeight);
                
                this.camera.position.z = 5;
                
                this.controls = new OrbitControls(this.camera, this.renderer.domElement);
                this.controls.enableDamping = true;
                this.controls.dampingFactor = 0.05;
                
                this.setupLights();
                this.setupEventListeners();
                this.loadSplatFile();
                this.animate();
            }
            
            setupLights() {
                const ambientLight = new THREE.AmbientLight(0xffffff, 0.5);
                this.scene.add(ambientLight);
                
                const directionalLight = new THREE.DirectionalLight(0xffffff, 0.8);
                directionalLight.position.set(1, 1, 1);
                this.scene.add(directionalLight);
            }
            
            setupEventListeners() {
                window.addEventListener('resize', () => {
                    this.camera.aspect = window.innerWidth / window.innerHeight;
                    this.camera.updateProjectionMatrix();
                    this.renderer.setSize(window.innerWidth, window.innerHeight);
                });
            }
            
            async loadSplatFile() {
                try {
                    const url = "https://huggingface.co/cakewalk/splat-data/resolve/main/nike.splat";
                    const response = await fetch(url);
                    
                    if (!response.ok) {
                        throw new Error(`Failed to load splat file: ${response.status} ${response.statusText}`);
                    }
                    
                    const data = await response.arrayBuffer();
                    this.processSplatData(data);
                    
                    this.loadingElement.style.display = 'none';
                } catch (error) {
                    console.error("Error loading splat file:", error);
                    this.loadingElement.textContent = `Error: ${error.message}`;
                }
            }
            
            processSplatData(data) {
                // This is a simplified implementation
                // In a real application, you would parse the .splat format
                // and create appropriate Three.js geometry for Gaussian splats
                
                // For demonstration, we'll create a simple point cloud
                const positions = [];
                const colors = [];
                const sizes = [];
                
                // Parse the binary splat data
                // This is a placeholder implementation
                const dataView = new DataView(data);
                let offset = 0;
                
                // Determine the number of splats (estimation)
                // In a real implementation, you would parse the header properly
                const bytesPerSplat = 32; // Estimation
                const numSplats = Math.floor(data.byteLength / bytesPerSplat);
                
                for (let i = 0; i < numSplats; i++) {
                    if (offset + bytesPerSplat > data.byteLength) break;
                    
                    // Extract position (simplified)
                    const x = dataView.getFloat32(offset, true);
                    const y = dataView.getFloat32(offset + 4, true);
                    const z = dataView.getFloat32(offset + 8, true);
                    
                    // Extract color (simplified)
                    const r = dataView.getUint8(offset + 12) / 255;
                    const g = dataView.getUint8(offset + 13) / 255;
                    const b = dataView.getUint8(offset + 14) / 255;
                    
                    // Extract size (simplified)
                    const size = dataView.getFloat32(offset + 16, true);
                    
                    positions.push(x, y, z);
                    colors.push(r, g, b);
                    sizes.push(size > 0 ? size : 0.1);
                    
                    offset += bytesPerSplat;
                }
                
                // Create point cloud geometry
                const geometry = new THREE.BufferGeometry();
                geometry.setAttribute('position', new THREE.Float32BufferAttribute(positions, 3));
                geometry.setAttribute('color', new THREE.Float32BufferAttribute(colors, 3));
                
                // Create material
                const material = new THREE.PointsMaterial({
                    size: 0.05,
                    vertexColors: true,
                    sizeAttenuation: true
                });
                
                // Create point cloud
                const pointCloud = new THREE.Points(geometry, material);
                this.scene.add(pointCloud);
                
                // Center the camera on the splat model
                const box = new THREE.Box3().setFromObject(pointCloud);
                const center = box.getCenter(new THREE.Vector3());
                const size = box.getSize(new THREE.Vector3());
                
                const maxDim = Math.max(size.x, size.y, size.z);
                const fov = this.camera.fov * (Math.PI / 180);
                const cameraDistance = maxDim / (2 * Math.tan(fov / 2));
                
                this.camera.position.copy(center);
                this.camera.position.z += cameraDistance * 1.5;
                this.controls.target.copy(center);
            }
            
            animate() {
                requestAnimationFrame(this.animate.bind(this));
                this.controls.update();
                this.renderer.render(this.scene, this.camera);
            }
        }

        // OrbitControls implementation
        class OrbitControls {
            constructor(camera, domElement) {
                this.camera = camera;
                this.domElement = domElement;
                this.target = new THREE.Vector3();
                this.enableDamping = false;
                this.dampingFactor = 0.05;
                
                this.rotateSpeed = 1.0;
                this.panSpeed = 0.5;
                this.zoomSpeed = 1.0;
                
                this.rotateStart = new THREE.Vector2();
                this.rotateEnd = new THREE.Vector2();
                this.rotateDelta = new THREE.Vector2();
                
                this.panStart = new THREE.Vector2();
                this.panEnd = new THREE.Vector2();
                this.panDelta = new THREE.Vector2();
                
                this.spherical = new THREE.Spherical();
                this.sphericalDelta = new THREE.Spherical();
                
                this.scale = 1;
                this.panOffset = new THREE.Vector3();
                
                this.STATE = {
                    NONE: -1,
                    ROTATE: 0,
                    PAN: 1
                };
                this.state = this.STATE.NONE;
                
                this.domElement.addEventListener('mousedown', this.onMouseDown.bind(this));
                this.domElement.addEventListener('wheel', this.onMouseWheel.bind(this));
                document.addEventListener('mousemove', this.onMouseMove.bind(this));
                document.addEventListener('mouseup', this.onMouseUp.bind(this));
                
                this.update();
            }
            
            onMouseDown(event) {
                event.preventDefault();
                
                if (event.button === 0) {
                    this.state = this.STATE.ROTATE;
                    this.rotateStart.set(event.clientX, event.clientY);
                } else if (event.button === 2) {
                    this.state = this.STATE.PAN;
                    this.panStart.set(event.clientX, event.clientY);
                }
            }
            
            onMouseMove(event) {
                if (this.state === this.STATE.ROTATE) {
                    this.rotateEnd.set(event.clientX, event.clientY);
                    this.rotateDelta.subVectors(this.rotateEnd, this.rotateStart);
                    
                    this.rotateLeft(2 * Math.PI * this.rotateDelta.x / this.domElement.clientWidth * this.rotateSpeed);
                    this.rotateUp(2 * Math.PI * this.rotateDelta.y / this.domElement.clientHeight * this.rotateSpeed);
                    
                    this.rotateStart.copy(this.rotateEnd);
                } else if (this.state === this.STATE.PAN) {
                    this.panEnd.set(event.clientX, event.clientY);
                    this.panDelta.subVectors(this.panEnd, this.panStart);
                    
                    this.pan(this.panDelta.x, this.panDelta.y);
                    
                    this.panStart.copy(this.panEnd);
                }
            }
            
            onMouseUp() {
                this.state = this.STATE.NONE;
            }
            
            onMouseWheel(event) {
                event.preventDefault();
                event.stopPropagation();
                
                if (event.deltaY < 0) {
                    this.dollyIn(this.getZoomScale());
                } else if (event.deltaY > 0) {
                    this.dollyOut(this.getZoomScale());
                }
            }
            
            getZoomScale() {
                return Math.pow(0.95, this.zoomSpeed);
            }
            
            rotateLeft(angle) {
                this.sphericalDelta.theta -= angle;
            }
            
            rotateUp(angle) {
                this.sphericalDelta.phi -= angle;
            }
            
            dollyIn(dollyScale) {
                this.scale /= dollyScale;
            }
            
            dollyOut(dollyScale) {
                this.scale *= dollyScale;
            }
            
            pan(deltaX, deltaY) {
                const distance = this.camera.position.distanceTo(this.target);
                const height = 2 * distance * Math.tan(this.camera.fov * Math.PI / 360);
                const width = height * this.camera.aspect;
                
                deltaX *= width / this.domElement.clientWidth * this.panSpeed;
                deltaY *= height / this.domElement.clientHeight * this.panSpeed;
                
                const cameraW = this.camera.up.clone().cross(this.camera.position.clone().sub(this.target)).normalize();
                const cameraU = cameraW.clone().cross(this.camera.up).normalize();
                
                this.panOffset.copy(cameraW.multiplyScalar(-deltaX));
                this.panOffset.add(cameraU.multiplyScalar(deltaY));
            }
            
            update() {
                const offset = new THREE.Vector3();
                
                offset.copy(this.camera.position).sub(this.target);
                
                // Convert to spherical coordinates
                this.spherical.setFromVector3(offset);
                
                // Apply rotation
                this.spherical.theta += this.sphericalDelta.theta;
                this.spherical.phi += this.sphericalDelta.phi;
                
                // Restrict phi to be between desired limits
                this.spherical.phi = Math.max(0.01, Math.min(Math.PI - 0.01, this.spherical.phi));
                
                // Apply scale
                this.spherical.radius *= this.scale;
                
                // Apply pan
                this.target.add(this.panOffset);
                
                // Convert back to Cartesian coordinates
                offset.setFromSpherical(this.spherical);
                
                // Apply position
                this.camera.position.copy(this.target).add(offset);
                this.camera.lookAt(this.target);
                
                // Reset changes
                this.sphericalDelta.set(0, 0, 0);
                this.scale = 1;
                this.panOffset.set(0, 0, 0);
                
                return true;
            }
        }

        // Wait for the DOM to load before starting the application
        document.addEventListener('DOMContentLoaded', () => {
            new GaussianSplatViewer();
        });
        
        // Prevent context menu on right-click for better controls
        document.addEventListener('contextmenu', (event) => {
            event.preventDefault();
        });
    </script>
</body>
</html>